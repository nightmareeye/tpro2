## Практическое занятие №10

# Отчёт по ПЗ

1. **Скриншот** таблицы Users и выведенных записей на консоль. Название базы данных должно совпадать с username. 
2. **Скриншот** таблицы Students с вставленными в неё пользователями. Название базы данных должно совпадать с username.
3. **Скриншот** выведенных записей из таблицы Students в файл и открытой таблицы с помощью sqlitebrowser.
4. **Скриншот** данных до и после обновления 3 за вами по журналу студента, поле "phonenumber".
5. **Скришоты** таблиц Session и Messages c 2 записями в каждой таблице.
# SQLite встраиваемая кросплатформенная база данных

SQLite - база данных, разработанная специально для мобильных и переносимых систем. Она не требует наличия сервера базы данных. Поддерживает весь набор команд SQL. К SQLite необходимо относиться как к очень удобному способу хранения данных в формате реляционных таблиц.

База данных SQLite3 хранится в одном файле со специальной организаций. Для переноса данных между компьютерами достаточно перенести файл. 

С плюсами познакомитесь во время работы, а теперь о минусах:
1. Минимальный набор команд, соответствующий SQL 92. Отсутствуют явные "плюшки".
2. Отсутсвует поддержка русского языка (поиск вхождений подстроки в строке). Проблема решается с помощью загрузки расширений. Расширение SQLite - набор команд, призванных решать какую-то конкретную проблему. В качестве примера приведём расширение icu - расширенные средства работы с Unicode, позволяющие подключить русский язык и осуществлять поиск.
3. Не подходит для хранения большого объёма информации.

## Установка пакета разработчика

Для компиляции программы необходимо установить пакет разработчика SQlite3. Это можно сделать с помощью команды:
```sudo apt-get install libsqlite3-dev```

Также сразу установим программу для просмотра баз данных SQLite3
```sudo apt-get install sqlitebrowser```

Далее создадим новый проект C++ в среде разработки CLion.Название проекта SQLite_TestApp. Внесём необходимые изменения в майл CMakeLists.txt
```
cmake_minimum_required (VERSION 3.15)
project (SQLite_TestApp )
set(CMAKE_CXX_STANDARD 14)
add_executable(SQLite_TestApp  main.cpp)
target_link_libraries(SQLite_TestApp LINK_PUBLIC sqlite3)
```
Последняя строка означает, что поиск исполняемых файлов, файлов заголовков и файлов статической компиляции будет осуществлён по стандартному пути расположения этих файлов в системе. По умолчанию все пакеты разработчика устанавливаются в 
```
/usr/lib
/usr/include
```

Теперь откроем файл main.cpp и добавим туда следующий код.
```
#include <iostream>
#include "sqlite3.h"

static int callback(void *data, int argc, char **argv, char **azColName){
    int i;
    fprintf(stderr, "%s: ", (const char*)data);

    for(i = 0; i<argc; i++) {
        printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
    }
    printf("\n");
    return 0;
}

int main(int argc, char* argv[]) {
    sqlite3 *db;// создаём переменную, которая будет указывать на открытую базу данных
    char *zErrMsg = 0;// в это строку будут записываться ошибки при выполнении запроса
    int rc;// идентификатор базы данных.
    char *sql;// SQL запрос. Для удобства можно хранить запросы в std::string
    const char* data = "Callback function called";//сообщение, которое будет передано обрабатывающей функции после выполнения SQL запроса

    /* Пытаемся открыть базу данных*/
    //Существует несколько способов открытия или создания базы данных. Если указать базе данных название бд "memory", то экземпляр БД будет создан в оперативной памяти и уничтожен при закрытии базы данных
    rc = sqlite3_open("test.db", &db);
    //База данных открыта успешно, если идентификатор равен 0
    if( rc ) {
        fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
        return(0);
    } else {
        fprintf(stderr, "Opened database successfully\n");
    }
    //текущий SQL запрос. Создадим таблицу с 3 столбцами, поле id будет являться первичным ключом, при добавлении данных он будет автоинкрементироваться
    sql = "CREATE TABLE IF NOT EXISTS Users(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, year INTEGER);";
    //получаем результат выполнения запроса
    rc = sqlite3_exec(db,//база данных, к которой будет идти запрос
            sql, // SQL запрос
            callback, // функция, которая будет вызвана после выполения запроса
            (void*)data,// данные, которая получит функция callback
            &zErrMsg// строка для записи ошибок
            );

    if( rc != SQLITE_OK ) {
        fprintf(stderr, "SQL error: %s\n", zErrMsg);
        sqlite3_free(zErrMsg);
    } else {
        fprintf(stdout, "Operation done successfully\n");
    }
    sqlite3_close(db);// закрытие базы данных
    return 0;
}
```
Рассмотрим подробнее, что происходит в программном коде.
1. Мы устанавливаем соединение с базой данных(в нашем случае при первом запуске создаём файл). Процесс установления соединения с базой данных является обязательным для работы с любой базой данных. Работа с базой данных обычно происходит от имени какого-либо пользователя, поэтому во время подключения может понадобиться указать логин и пароль от учётной записи пользователя базы данных. В нашем случае база данных представляет собой специальный файл, в котором хранятся данные, а интерфейс sqlite3 позволяет с ним работать, как с базой данных. В таких базах данных, как PostgreSQL, Oracle, SQLServer работа с файлами баз данных осуществляется не напрямую, а с помощью специальной программы - сервера базы данных. Именно с ним вы сначала устанавливаете соединение по протоколу TCP/IP, проходите процедуру авторизации, а далее сервер базы данных выделяет вам отдельное соединение для работы с ней.
2. Именно сервер базы данных выполняет ваш запрос. Запрос отправляется по открытому с сервером соединению и после выполнения данные отправляются клиенту.
3. В функцию sqlite3_exec() мы передали такой параметр,как callback. Точнее мы передали указатель на функцию. Функции, как и любой другой объект языка можно передавать, как параметры. Это является очень удобным механизмом в программировании.Callback или функция обратного вызова в программировании — передача исполняемого кода в качестве одного из параметров другого кода. Обратный вызов позволяет в функции исполнять код, который задаётся в аргументах при её вызове. Этот код может быть определён в других контекстах программного кода и быть недоступным для прямого вызова из этой функции. Некоторые алгоритмические задачи в качестве своих входных данных имеют не только числа или объекты, но и действия (алгоритмы), которые естественным образом задаются как обратные вызовы. В нашем случае, функция обратного вызова имеет строгое определение,которое задаётся интерфейсом sqlite3. После извлечения запроса в функцию обратного вызова передаются указатели на считанные данные для дальнейшей их обработки. Вызов callback функции происходит тогда, когда его вызывает другой исполняемый код. При работе с готовыми библиотеками необходимо смотреть спецификацию библиотеки для определения случаев, когда функция callback будет вызываться, а когда нет.

 ## Выполнение операций вставки, считывания и обновления данных в БД

Добавим функцию InsertFunc, которая будет добавлять 3 пользователей в существующую таблицу, и функцию SelectFunc, которая будет выводить список пользователей на экран.

Теперь добавим программное меню,состояшие из 2 пунктов:
1. Считать данные
2. Вывести данные на экран.

Таким образом исходный код выглядит следующим образом:
```
#include <iostream>
#include "sqlite3.h"

static int callback(void *data, int argc, char **argv, char **azColName){
    int i;
    fprintf(stderr, "%s: ", (const char*)data);

    for(i = 0; i<argc; i++) {
        printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
    }
    printf("\n");
    return 0;
}

void InsertFunc(sqlite3 *db,void *data,char *zErrMsg){
    char *insertSQlCommand = "INSERT INTO Users (name,year) VALUES ('Иванов',1999),('Петров',2001),('Сидоров',1980)";
    int result = sqlite3_exec(db,insertSQlCommand,callback,(void*)data,&zErrMsg);
    if(result != SQLITE_OK){
        fprintf(stderr, "SQL error: %s\n", zErrMsg);
        sqlite3_free(zErrMsg);
    }
}

void SelectFunc(sqlite3 *db,void *data,char *zErrMsg){
    char *selectSQlCommand = "Select * from Users";
    int result = sqlite3_exec(db,selectSQlCommand,callback,data,&zErrMsg);
    if(result != SQLITE_OK){
        fprintf(stderr, "SQL error: %s\n", zErrMsg);
        sqlite3_free(zErrMsg);
    }
    else{
        fprintf(stderr, "Inserted data successfully\n");
    }
}

int main(int argc, char* argv[]) {
    sqlite3 *db;// создаём переменную, которая будет указывать на открытую базу данных
    char *zErrMsg = 0;// в это строку будут записываться ошибки при выполнении запроса
    int rc;// идентификатор базы данных.
    char *sql;// SQL запрос. ДЛя удобства можно хранить запросы в std::string
    const char* data = "Callback function called";//сообщение, которое будет передано обрабатывающей функции после выполнения SQL запроса

    /* Путаемся открыть базу данных*/
    //Существует несколько способов открытия или создания базы данных. Если указать базе данных название бд "memory", то экземпляр БД будет создан в оперативной памяти и уничтожен при закрытии базы данных
    rc = sqlite3_open("test.db", &db);
    //База данных открыта успешна, если идентификатор равен 0
    if( rc ) {
        fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
        return(0);
    } else {
        fprintf(stderr, "Opened database successfully\n");
    }
    //текущий SQL запрос. Создадим таблицу с 3 столбцами, поле id будет являться первичным ключом, при добавлении данных он будет автоинкрементироваться
    sql = "CREATE TABLE IF NOT EXISTS Users(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, year INTEGER);";
    //получаем результат выполнения запроса
    rc = sqlite3_exec(db,//база данныъх, к которой будет идти запрос
            sql, // SQL запрос
            callback, // функция, которая будет вызвана после выполения запроса
            (void*)data,// данные, которая получит функция callback
            &zErrMsg// строка для записи ошибок
            );

    if( rc != SQLITE_OK ) {
        fprintf(stderr, "SQL error: %s\n", zErrMsg);
        sqlite3_free(zErrMsg);
    } else {
        int menu;
        while(true){
            std::cout << "Select menu" << std::endl <<std::flush;
            std::cin >> menu;
            switch(menu){
                case 1:{
                    InsertFunc(db,(void*)data,zErrMsg);
                    break;
                }
                case 2:{
                    SelectFunc(db,(void*)data,zErrMsg);
                    break;
                }
            }
        }
    }

    sqlite3_close(db);// закрытие базы данных
    return 0;
}
```

Если операция вставки была выполнена успешно, то откроем базу данных с помощью программы sqlitebrowser. Её можно запустить с помощью консоли. Перейдите во вкладку Browser Data и убедитесь,что все записи присутствуют в базе данных.
Также вы можете выполнить команду ```cat test.db``` для просмотра структуры файла.

Выведите данные на экран после выполнения операции вставки, откройте sqlitebrowser и сравните одинаковы ли записи были выведены на экран.

Замените название базы данных на username, выполните действия указанные выше. На **скриншоте** продемонстрировать открытый sqlitebrowser с открытой таблицей Users и выведенными данными в консоль. На **скриншоте** обызательно должно быть видно название базы данных.

## Задание

1. Создайте таблицу Students с полями "id", "username", "birthday", "city","phoneNumber". База данных должна иметь название, совпадающее с вашим username.
2. Добавьте в таблицу Students 5 человек, следующих за вами по журналу. Сделайте **скриншот** таблицы Students в sqlitebrowser, на котором видны добавленные студенты.
3. В функцию SelectFunc вместо текстового поля передайте название файла "username-Students.txt", в которой будет записана текущая таблица. В Функции callback создайте файл с указанным названием, выведите туда существующие записи из базы данных. Запись осуществлять построчно,чтобы информация об одном студенте располагалась на одной строке. Сделайте **скриншот** открытого файла и таблицы, открытой с помощью sqlitebrowser.
4. Обновите таблицу, для 3 человека после вас по журналу обновите поле "phonenumber". На **скриншоте** продемонстрировать таблицу до и после операций вставки и обновления. Обновить данные для существующей записи можно с помощью оператора UPDATE. Пример, ```UPDATE Users SET name = fio where id = 2```. Это означает, что для записи, имеющей идентификатор 2, поле "name" будет обновлено. 
5. Используя разработанный клиент и сервер в ПЗ7, на стороне сервера реализовать хранение следующих данных в базе данных, название базы данных должно совпадать с username:
    1. Создайте таблицу Clients с полями "IP", "username", в которую должны добавляться пользователи, которые впервые подключаются к серверу.
    2. Создайте таблицу Messages с полями "messageID", "messageText", "sendTime", "from". В таблицу должны добавляться все сообщения приходящие на сервер.
    3. Создайте таблицу Session с полями "IP", "startTime", "stopTime","messageCount", в которой будем хранить историю подключений пользователей к серверу. В момент подключения создавать запись. В момент отключения обновлять запись и указывать время выхода.
    4. Подключитесь  к своему серверу, отравьте сообщения на сервер. Количество повторных подключений и отправленных сообщений должно совпадать с номером вашего курса(т.е 2). На **скриншотах** продемонстрировать таблицы Messages и Session. На **скриншотах** обязательно должен быть ваш username.  
