# Домашнее задание

В рамках дополнительной демонстрации работы с сетью, в частности взаимодействия по протоколам TCP/IP, вам предлагается вместе с автором построить приложение - мессенджер. Для вас исходный код клиентской и серверной части будет изначально доступен. Здесь не будет разбора непосредственно кода(почему там указатель, почему ссылка или допустим std:cout, а не printf), будут освещены основные идеи, которые закладываются в построение клиент-серверных приложений. Таким образом, в статье будут освещены следующие моменты:

1. Протокол взаимодействия клиента и сервера
2. Логика работы клиента
3. Логика работы сервера

И так, начнём.

 ## Протокол взаимодействия

 Самое важное при разработке клиент-серверных приложений: определение протокола взаимодействия. Протокол - некий язык взаимодействия понятный клиенту и серверу. Протокол не должен зависеть от каких-то особенностей языка программирования. В качестве примера, вы можете разработать сервер приложения с помощью языка C++, так как необходима высокая скорость работы( не обольщайтесь, кривые руки всё портят) и клиент приложения на C# или Java или Python. Суть одна - язык взаимодействия должен быть понятен обеим сторонам. 

 Определим, что мы бы хотели видеть при использовании нашего мессенджера:
 
1. При подключении к серверу отправлять данные о себе - производить регистрацию
2. Получать список клиентов, которые подключены к серверу
3. Отправлять конкретному клиенту текстовое сообщение

Взаимодействие, как и в ПЗ-7, будет осуществляться с помощью упаковки протокола в формат json. Формат может быть любым, но именно json используется повсеместно, он понятен и прост.

Определим базовый вид сообщения
```
{
"command":"",
"from":"",
"message_id":"",
"text":{
    "clientID":"",
    "message":"",
    "name":""
    },
"time":""}
```
Соответственно разберём для чего необходимо каждое поле. **Данная реализация выбор только автора, при разработке своих приложений вы можете выбирать другой формат.**

"command" - команда, которую должен выполнить сервер, в нашем случае это всего 5 команды: 
- "auth" - регистрация при подключении или переподключении
- "response" - ответ клиенту на запрос к серверу
- "get_online_user" - получение списка онлайн пользователей
- "exception" - сообщает клиенту, что что-то пошло не так при выполнении его команды
- "new_message" - сообщение клиенту о новом сообщении

"from" - указывает объект, кому было направлено сообщение, в нашем случае это "server" и "client".

"message_id" - при отправке любого сообщения на сервер клиент присваивает ему уникальный номер. Использование уникального номера будет освещено в рамках разработки клиента.

"text" - в нём могут присутсвовать совершенно разные поля, это добавляет вариативности. "clientID" - уникальный идентификатор пользователя, генерируется при каждом запуске клиента приложения. По хорошему, данное поле должно генерироваться сервером при первом подключении к сереру, а дальше сообщаться клиенту и храниться на стороне клиента в защищённом виде. Но в нашем случае, чтобы не усложнять приложение, мы этого делать не будем и не приследуем такой цели.

"time" - время отправки сообщения на сервер.

В качестве демонстрации привёдем примеры сгенерированных пакетов.
```
Пакет, который клиент отправляет серверу при подключении к нему:
{
    "command":"auth",
    "from":"server",
    "message_id":"37975127259337627132",
    "text":{"clientID":"fllFh523Cz","message":"hello server","name":"TEST"},
    "time":""
}
Пакет, который сервер отправляет клиенту после регистрации. В поле users передаётся массив json-объектов,в котором перечислены пользователи установившие соединение с сервером. "user_message_id" - номер пакета, на который отвечает сервер.
{
    "command":"response",
    "text":"Hello, TESTYou join to chat",
    "user_message_id":"37975127259337627132",
    "users":[{"clientID":"fllFh523Cz","name":"TEST"}]
}
Запросим у сервера список пользователей, которые подключены к сети.
{
    "command":"get_online_user",
    "from":"server",
    "message_id":"62671085628980212047",
    "text":{"clientID":"lUmOkPQAa3","message":"","name":"123"},
    "time":""
}

Отправленное сообщение клиенту с идентификатором 1234(данный пользователь не подключен к серверу).
{
    "command":"new_message",
    "from":"client",
    "message_id":"09711528991433648480",
    "text":{"clientID":"fllFh523Cz","message":"exception","name":"TEST","online_userID":"1234"},
    "time":""
}

В ответ на пакет выше сервер ответит клиенту, отправившему сообщение, следующее:
{
    "command":"exception",
    "exception":"Client close connection or you input not valid ID"
}
Таким образом мы сообщаем клиенту, что пользователь, которому он отправил сообщение отключился от сети, либо пользователь ввёл неверный идентификатор другого пользователя
 ```

Таким образом мы рассмотрели созданный нами протокол.

## Клиентская часть

Клиентское приложение будет консольным.

Рассмотрим классы, которые мы будет использовать для реализации клиента. Исходный код клиента тут

- Message - представляет собой объект, который является обёрткой над тем пакетом, который будет отправлен на сервер
- NetworkManager - класс, который описывает взаимодействие с сетью. Именно он пытается подключиться к серверу, отсылает и принимает пакеты
- Messenger - представляет класс, который будет транслировать действия пользователя в отправляемые пакеты

Этих 3 простых классов достаточно, чтобы описать простейшую реализацию клиента. 

### Важные моменты
 Исходный код не будет разбираться, только сами идеи.
 
1. В приложении будет 3 потока: поток взаимодействия с пользователем приложения, поток отправки сообщений на сервер, поток чтения сообщений с сервера. 

Изучая исходный код, вы должны заметить, что отправка сообщений происходит внутри цикла. Это связанно со следующим моментом: представим ситуацию, что вы случайно отключились от сети, а затем снова подключились(сейчас имеется ввиду физическая сеть Ethernet). Если не зацикливать отправку сообщений, то вы попросту потеряете сообщение, а таким образом вы перехватите исключение, обработаете его и сохраните сообщение.

Рассмотрим поток чтения сообщений с сервера. Рассмотрим его отличия от примера в ПЗ. Внутри цикла есть момент обработки отключения сервера. Как вы видите, в исходный код встроен счётчик, который вы зададите при первой попытке подключения к серверу. После каждой неуспешной попытки подключения к серверу, поток "засыпает" на 2 секунды, а затем оживает. Это продолжается пока количество попыток н не иссякнет. Обратите внимание, что после успешного переподключения мы заново отправляем наши регистрационные данные.

2. Как вы можете заметить, во многих местах исходного кода встречается обработка исключений. Это очень важный механизм, который позволяет вам выявлять ошибки в приложении и реализовывать более сложную логику. Настоятельно рекомендуется самостоятельно изучить обработку исключений.

3. Наверное, самое интересное, что может здесь быть. При отправке сообщения на сервер, мы храним пары значений :  ```{идентификатор сообщения - функция обратного вызова}```. Представим такую ситуацию, что на каждый пакет сервер отвечает совершенно разными сообщениями, что зачастую правильно. Функция обратного вызова позволяет связть конкретное сообщение и его обработку, таким образом вы за каждым сообщением закрепляете обработчик, который заранее знает как парсить ответное сообщение.

## Серверная часть

Серверное приложение тоже будет консольным.

Рассмотрим основные классы, которые будут использованы нами для реализации сервера приложения. Исходный код сервера тут.

- Client - класс, описывающий подключенного клиента. За каждым клиентом закреплено его имя и открытый сокет для взаимодействия с ним
- Connection - класс, который реализует чтение сообщений от клиента
- Server - класс, являющийся реализацией паттерна Одиночка(Singlton). Плюсы и минусы использования данного паттерна вам необходимо изучить самостоятельно. В нашем же случае, использование паттерна Одиночка позволяет экземплярам класса Connection получать доступ к сущности, которая была инициализирована всего 1 раз за весь жизненный цикл работы сервера. Таким образом они все взаимодействуют с одним и тем же объектом.

### Важные моменты

1. В одном небольшом месте исходного кода используется регулярное выражение. Не стоит пугаться, оно совершенно простое. Это очнь важная тема, которая будет вам встречаться на протяжении всей карьеры разработчика
2. Не забываем про обработку исключений
3. Храним на сервере пары значений ``` {идентфикатор пользователя - соответствующий ему экземпляр класса клиент}```. С помощью данной связки мы можем организовать взаимодейтсвие между пользователями. Как это происходит: при первом подключении пользователя он передаёт серверу свой уникальный идентификатор и имя, на сервере создаётся экземпляр класса Client(в нём открыто соединение с клиентом с помощью передачи streamSocket) и данная пара добавляется в контейнер для хранения. Далее подключается 2 клиент, происходит всё тоже самое. Каждый из клиентов запросил список онлайн пользователей и теперь они знают о друг друге. Теперь пользователь 1 отправляет сообщение пользователю 2 зная его идентификатор. Сервер обрабатывает сообщение от первого клиента, находит второго пользователя в контейнере зная идентификатор 2 пользователя. У сервера открыто соединение со вторым пользователем, теперь он с помощью этого открытого соединения передаёт сообщение 2 пользователю и 2 пользователь получает сообщение. 

